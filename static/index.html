<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Rust Parser Playground</title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/codemirror.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/mode/rust/rust.min.js"></script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/theme/vscode-light.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/theme/vscode-dark.min.css" />

  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.2/d3.min.js"></script>

  <style>
    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    /* æµ…/æ·±è‰²ä¸»é¢˜å˜é‡ */
    :root[data-theme="light"] {
      --bg-main: #ffffff;
      --fg-main: #000000;
      --border: #d4d4d4;
      --header-bg: #f3f3f3;
      --error-bg: #ffebee;
      /* æ›´æŸ”å’Œçš„é”™è¯¯èƒŒæ™¯ */
      --error-fg: #c62828;
      /* æ›´æ·±çš„é”™è¯¯å‰æ™¯ */
      --editor-bg: #ffffff;
      --gutter-bg: #f3f3f3;
      --gutter-fg: #5a5a5a;
      --node-color: #0064c8;
      /* è¯­æ³•æ ‘èŠ‚ç‚¹é¢œè‰² */
      --node-text: #000000;
      /* è¯­æ³•æ ‘æ–‡å­—é¢œè‰² */
      --link-color: #555555;
      /* è¯­æ³•æ ‘è¿æ¥çº¿é¢œè‰² */
      --table-header-bg: #e0e0e0;
      /* è¡¨æ ¼å¤´éƒ¨èƒŒæ™¯ */
      --table-row-even-bg: #f9f9f9;
      /* è¡¨æ ¼å¶æ•°è¡ŒèƒŒæ™¯ */
      --table-row-hover-bg: #eef6ff;
      /* è¡¨æ ¼è¡Œæ‚¬æµ®èƒŒæ™¯ */
      --button-active-bg: #0064c8;
      /* æ¿€æ´»æŒ‰é’®èƒŒæ™¯ */
      --button-active-fg: #ffffff;
      /* æ¿€æ´»æŒ‰é’®æ–‡å­— */
      --tree-hover-node: #FFA000;
      /* æ‚¬åœèŠ‚ç‚¹é¢œè‰² - æµ…è‰² */
      --tree-hover-link: #FFA000;
      /* æ‚¬åœè¿æ¥çº¿é¢œè‰² - æµ…è‰² */
      --tree-subtree-highlight: #4CAF50;
      /* å­æ ‘é«˜äº®é¢œè‰² - æµ…è‰² */
    }

    :root[data-theme="dark"] {
      --bg-main: #1e1e1e;
      --fg-main: #d4d4d4;
      /* è°ƒæ•´æš—è‰²ä¸»é¢˜ä¸‹çš„é»˜è®¤æ–‡å­—é¢œè‰² */
      --border: #3c3c3c;
      --header-bg: #2d2d2d;
      --error-bg: #3e1e1e;
      /* æ›´æŸ”å’Œçš„é”™è¯¯èƒŒæ™¯ */
      --error-fg: #f48fb1;
      /* æ›´äº®çš„é”™è¯¯å‰æ™¯ */
      --editor-bg: #1e1e1e;
      /* ç¼–è¾‘å™¨èƒŒæ™¯ä¸ä¸»èƒŒæ™¯ä¸€è‡´ */
      --gutter-bg: #2d2d2d;
      --gutter-fg: #858585;
      --node-color: #4fc3f7;
      /* è¯­æ³•æ ‘èŠ‚ç‚¹é¢œè‰² */
      --node-text: #d4d4d4;
      /* è¯­æ³•æ ‘æ–‡å­—é¢œè‰² */
      --link-color: #6a6a6a;
      /* è¯­æ³•æ ‘è¿æ¥çº¿é¢œè‰² */
      --table-header-bg: #333333;
      /* è¡¨æ ¼å¤´éƒ¨èƒŒæ™¯ */
      --table-row-even-bg: #2c2c2c;
      /* è¡¨æ ¼å¶æ•°è¡ŒèƒŒæ™¯ */
      --table-row-hover-bg: #373737;
      /* è¡¨æ ¼è¡Œæ‚¬æµ®èƒŒæ™¯ */
      --button-active-bg: #4fc3f7;
      /* æ¿€æ´»æŒ‰é’®èƒŒæ™¯ */
      --button-active-fg: #1e1e1e;
      /* æ¿€æ´»æŒ‰é’®æ–‡å­— */
      --tree-hover-node: #FFCA28;
      /* æ‚¬åœèŠ‚ç‚¹é¢œè‰² - æš—è‰² */
      --tree-hover-link: #FFCA28;
      /* æ‚¬åœè¿æ¥çº¿é¢œè‰² - æš—è‰² */
      --tree-subtree-highlight: #81C784;
      /* å­æ ‘é«˜äº®é¢œè‰² - æš—è‰² */
    }

    :root[data-theme="dark"] .CodeMirror-cursor {
      border-left: 1px solid var(--fg-main);
    }

    /* å…¨å±€å¸ƒå±€ */
    body {
      margin: 0;
      height: 100vh;
      display: flex;
      overflow: hidden;
      background: var(--bg-main);
      color: var(--fg-main);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    }

    /* å·¦ä¾§åŒºåŸŸ */
    #left-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 300px;
      /* æœ€å°å®½åº¦ */
      border-right: 1px solid var(--border);
    }

    /* å³ä¾§åŒºåŸŸ */
    #right-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 300px;
      /* æœ€å°å®½åº¦ */
    }

    /* ç¼–è¾‘å™¨åŒºåŸŸ */
    #editor-container {
      flex: 3;
      /* ç¼–è¾‘å™¨å æ¯”æ›´å¤§ */
      display: flex;
      flex-direction: column;
      min-height: 200px;
      /* æœ€å°é«˜åº¦ */
    }

    /* æŠ¥é”™ä¿¡æ¯åŒºåŸŸ */
    #error-container {
      flex: 1;
      /* æŠ¥é”™ä¿¡æ¯å æ¯”å‡å° */
      display: flex;
      flex-direction: column;
      border-top: 1px solid var(--border);
      min-height: 100px;
      /* æœ€å°é«˜åº¦ */
    }

    #theme-toggle {
      background: none;
      border: none;
      color: var(--fg-main);
      cursor: pointer;
      font-size: 1.2em;
    }

    /* CodeMirror æ ·å¼ */
    .CodeMirror {
      flex: 1;
      height: auto;
      /* è‡ªåŠ¨é«˜åº¦ */
      font-size: 14px;
      font-weight: bold;
      background: var(--editor-bg) !important;
      color: var(--fg-main) !important;
      /* CodeMirror æ–‡å­—é¢œè‰² */
    }

    .CodeMirror-gutters {
      background: var(--gutter-bg) !important;
      border-right: 1px solid var(--border) !important;
    }

    .CodeMirror-linenumber {
      color: var(--gutter-fg) !important;
    }

    /* ä¿ç•™ CodeMirror é»˜è®¤ä¸»é¢˜çš„æ³¨é‡Šé«˜äº® */
    .cm-s-vscode-light .cm-comment {
      color: #008000;
    }

    .cm-s-vscode-dark .cm-comment {
      color: #6A9955;
    }


    /* æŠ¥é”™ä¿¡æ¯æ ·å¼ */
    #error-info {
      flex: 1;
      padding: 10px;
      /* å¢åŠ å†…è¾¹è· */
      overflow-y: auto;
      font-family: monospace;
      white-space: pre-wrap;
      font-size: 0.9em;
      line-height: 1.4;
    }

    .cm-error-underline {
      text-decoration: var(--error-fg) wavy underline;
      /* ä½¿ç”¨ä¸»é¢˜é¢œè‰² */
      text-decoration-skip-ink: none;
      /* ç¡®ä¿æ³¢æµªçº¿è¿ç»­ */
    }


    /* å³ä¾§å†…å®¹åŒºåŸŸ */
    #right-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      /* é˜²æ­¢å†…éƒ¨æº¢å‡ºå½±å“å¸ƒå±€ */
    }

    #display-selector {
      padding: 6px 8px;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: var(--bg-main);
      color: var(--fg-main);
      margin-right: 10px;
    }

    .tab-controls button {
      background: none;
      border: 1px solid var(--border);
      color: var(--fg-main);
      padding: 6px 10px;
      margin-left: 5px;
      border-radius: 4px;
      cursor: pointer;
    }

    /* å³ä¾§å†…å®¹æ˜¾ç¤ºåŒºåŸŸ */
    #content-display {
      flex: 1;
      position: relative;
      /* ä¸ºäº†å†…éƒ¨ absolute å®šä½çš„ .content-pane */
      overflow: hidden;
    }

    .content-pane {
      position: absolute;
      width: 100%;
      height: 100%;
      display: none;
      /* é»˜è®¤éšè— */
      overflow: auto;
      /* å†…å®¹è¶…å‡ºæ—¶æ»šåŠ¨ */
      padding: 10px;
      box-sizing: border-box;
    }

    .content-pane.active {
      display: block;
      /* æ¿€æ´»æ—¶æ˜¾ç¤º */
    }

    /* ä¸»é”™è¯¯è¦†ç›–å±‚ */
    .error-display-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: rgba(128, 0, 0, 0.05);
      color: var(--error-fg);
      font-weight: bold;
      font-size: 1.2em;
      z-index: 10;
      border: 1px solid var(--error-fg);
      border-radius: 4px;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
    }

    /* --- è¯­æ³•æ ‘ç¾åŒ–åŠHoveræ•ˆæœ CSS --- */
    #syntax-tree-container {
      width: 100%;
      height: 100%;
    }

    #tree-svg {
      width: 100%;
      height: 100%;
      display: block;
      background-color: var(--bg-main);
      /* è®¾ç½®SVGèƒŒæ™¯è‰² */
    }

    .link {
      fill: none;
      stroke: var(--link-color);
      stroke-width: 1px;
      stroke-opacity: 0.7;
      transition: stroke 0.2s, stroke-width 0.2s;
      /* æ·»åŠ è¿‡æ¸¡æ•ˆæœ */
    }

    .node circle {
      fill: var(--node-color);
      stroke: var(--border);
      stroke-width: 1.5px;
      r: 7px;
      transition: fill 0.2s;
      /* æ·»åŠ è¿‡æ¸¡æ•ˆæœ */
    }

    .node text {
      font-size: 11px;
      /* è°ƒæ•´æ–‡å­—å¤§å° */
      fill: var(--node-text);
      text-anchor: middle;
      dominant-baseline: central;
      paint-order: stroke;
      /* è®©æè¾¹åœ¨å¡«å……ä¹‹ä¸‹ */
      stroke: var(--bg-main);
      /* æ–‡å­—æè¾¹ï¼Œç”¨èƒŒæ™¯è‰²åˆ¶é€ "å…‰æ™•"æ•ˆæœ */
      stroke-width: 3px;
      stroke-linecap: butt;
      stroke-linejoin: miter;
    }

    /* å•ä¸ªèŠ‚ç‚¹Hoveræ•ˆæœ (å¯é€‰, å¦‚æœå¸Œæœ›ä¸å­æ ‘é«˜äº®åŒºåˆ†æˆ–å åŠ ) */
    .node.node--hover circle {
      /* æ³¨æ„é€‰æ‹©å™¨å˜åŒ–ï¼Œç›´æ¥ä½œç”¨äºnodeçš„gå…ƒç´  */
      fill: var(--tree-hover-node);
      stroke: var(--tree-hover-node);
      stroke-width: 2px;
    }

    .node.node--hover text {
      font-weight: bold;
    }

    .link.link--hover {
      /* æ³¨æ„é€‰æ‹©å™¨å˜åŒ– */
      stroke: var(--tree-hover-link);
      stroke-width: 2.5px;
      stroke-opacity: 1;
    }

    /* å­æ ‘é«˜äº®æ•ˆæœ */
    .node.subtree-highlight circle {
      /* ä½œç”¨äºnodeçš„gå…ƒç´  */
      fill: var(--tree-subtree-highlight);
      stroke-width: 2px;
      stroke: var(--tree-subtree-highlight);
    }

    .node.subtree-highlight text {
      font-weight: bold;
      fill: var(--fg-main);
      /* å¯ä»¥ä¸ºé«˜äº®å­æ ‘çš„æ–‡å­—æŒ‡å®šç‰¹å®šé¢œè‰² */
    }

    .link.subtree-highlight {
      /* ä½œç”¨äºlinkè·¯å¾„ */
      stroke: var(--tree-subtree-highlight);
      stroke-width: 2px;
      stroke-opacity: 1;
    }

    /* --- è¯­æ³•æ ‘ CSS ç»“æŸ --- */


    /* ä¸­é—´ä»£ç /å››å…ƒå¼è¡¨æ ¼æ ·å¼ */
    #quadruples-container {
      width: 100%;
      height: 100%;
      overflow: auto;
    }

    .quadruple-table {
      width: 100%;
      border-collapse: collapse;
      font-family: monospace;
      font-size: 0.85em;
      table-layout: auto;
    }

    .quadruple-table th,
    .quadruple-table td {
      padding: 8px 10px;
      text-align: left;
      border: 1px solid var(--border);
      white-space: pre;
    }

    .quadruple-table th {
      background-color: var(--table-header-bg);
      position: sticky;
      top: 0;
      z-index: 1;
    }

    .quadruple-table tr:nth-child(even) {
      background-color: var(--table-row-even-bg);
    }

    .quadruple-table tr:hover {
      background-color: var(--table-row-hover-bg);
    }

    /* è§£æè¡¨ç¤ºæ · */
    .table-switcher {
      padding: 8px 12px;
      background: var(--header-bg);
      border-bottom: 1px solid var(--border);
    }

    .table-btn {
      background: none;
      border: 1px solid var(--border);
      color: var(--fg-main);
      padding: 6px 12px;
      margin-right: 5px;
      cursor: pointer;
      border-radius: 4px;
      transition: background-color 0.2s, color 0.2s;
    }

    .table-btn.active {
      background: var(--button-active-bg);
      color: var(--button-active-fg);
      border-color: var(--button-active-bg);
    }

    .tables-wrapper {
      flex: 1;
      overflow: auto;
      position: relative;
      height: calc(100% - 45px);
    }

    .parse-table {
      position: absolute;
      width: 100%;
      height: 100%;
      display: none;
      overflow: auto;
    }

    .parse-table.active {
      display: block;
    }

    .parse-table table {
      border-collapse: collapse;
      width: max-content;
      min-width: 100%;
      font-family: monospace;
      font-size: 0.8em;
    }

    .parse-table th {
      background: var(--table-header-bg);
      position: sticky;
      top: 0;
      z-index: 1;
      border: 1px solid var(--border);
      padding: 6px 10px;
    }

    .parse-table td {
      border: 1px solid var(--border);
      padding: 4px 8px;
      text-align: center;
      white-space: nowrap;
    }

    .parse-table .shift {
      color: #4CAF50;
    }

    .parse-table .reduce {
      color: #FF9800;
    }

    .parse-table .accept {
      color: #2196F3;
      font-weight: bold;
    }


    /* --- è‡ªå®šä¹‰ Token é«˜äº®æ ·å¼ --- */
    .token-LET,
    .token-FN,
    .token-FOR,
    .token-IN,
    .token-WHILE,
    .token-IF,
    .token-ELSE,
    .token-RETURN,
    .token-LOOP,
    .token-BREAK,
    .token-CONTINUE {
      color: #C586C0;
    }

    .token-MUT {
      color: #D16D9E;
      font-style: italic;
    }

    .token-IDENTIFIER {
      color: #9CDCFE;
    }

    .token-MACRO_IDENTIFIER {
      color: #4EC9B0;
      font-style: italic;
    }

    .token-I32 {
      color: #4EC9B0;
    }

    .token-INTEGER_CONSTANT,
    .token-FLOATING_POINT_CONSTANT {
      color: #B5CEA8;
    }

    .token-CHAR_CONSTANT,
    .token-STRING_CONSTANT {
      color: #CE9178;
    }

    .token-S_COMMENT,
    .token-LM_COMMENT,
    .token-RM_COMMENT {
      color: #6A9955;
      font-style: italic;
    }

    .token-ASSIGN,
    .token-PLUS,
    .token-MINUS,
    .token-MULT,
    .token-DIV,
    .token-EQ,
    .token-GT,
    .token-GE,
    .token-LT,
    .token-LE,
    .token-NEQ,
    .token-ARROW {
      color: #D4D4D4;
    }

    .token-LPAREN,
    .token-RPAREN,
    .token-LBRACE,
    .token-RBRACE,
    .token-LBRACK,
    .token-RBRACK,
    .token-SEMICOLON,
    .token-COLON,
    .token-COMMA,
    .token-DOT,
    .token-DOTDOT,
    .token-AMP {
      color: #808080;
    }

    :root[data-theme="light"] .token-LET,
    :root[data-theme="light"] .token-FN,
    :root[data-theme="light"] .token-FOR,
    :root[data-theme="light"] .token-IN,
    :root[data-theme="light"] .token-WHILE,
    :root[data-theme="light"] .token-IF,
    :root[data-theme="light"] .token-ELSE,
    :root[data-theme="light"] .token-RETURN,
    :root[data-theme="light"] .token-LOOP,
    :root[data-theme="light"] .token-BREAK,
    :root[data-theme="light"] .token-CONTINUE {
      color: #0000FF;
    }

    :root[data-theme="light"] .token-MUT {
      color: #AF00DB;
      font-style: italic;
    }

    :root[data-theme="light"] .token-IDENTIFIER {
      color: #001080;
    }

    :root[data-theme="light"] .token-MACRO_IDENTIFIER {
      color: #267F99;
      font-style: italic;
    }

    :root[data-theme="light"] .token-I32 {
      color: #267F99;
    }

    :root[data-theme="light"] .token-INTEGER_CONSTANT,
    :root[data-theme="light"] .token-FLOATING_POINT_CONSTANT {
      color: #098658;
    }

    :root[data-theme="light"] .token-CHAR_CONSTANT,
    :root[data-theme="light"] .token-STRING_CONSTANT {
      color: #A31515;
    }

    :root[data-theme="light"] .token-S_COMMENT,
    :root[data-theme="light"] .token-LM_COMMENT,
    :root[data-theme="light"] .token-RM_COMMENT {
      color: #008000;
      font-style: italic;
    }

    :root[data-theme="light"] .token-ASSIGN,
    :root[data-theme="light"] .token-PLUS,
    :root[data-theme="light"] .token-MINUS,
    :root[data-theme="light"] .token-MULT,
    :root[data-theme="light"] .token-DIV,
    :root[data-theme="light"] .token-EQ,
    :root[data-theme="light"] .token-GT,
    :root[data-theme="light"] .token-GE,
    :root[data-theme="light"] .token-LT,
    :root[data-theme="light"] .token-LE,
    :root[data-theme="light"] .token-NEQ,
    :root[data-theme="light"] .token-ARROW {
      color: #000000;
    }

    :root[data-theme="light"] .token-LPAREN,
    :root[data-theme="light"] .token-RPAREN,
    :root[data-theme="light"] .token-LBRACE,
    :root[data-theme="light"] .token-RBRACE,
    :root[data-theme="light"] .token-LBRACK,
    :root[data-theme="light"] .token-RBRACK,
    :root[data-theme="light"] .token-SEMICOLON,
    :root[data-theme="light"] .token-COLON,
    :root[data-theme="light"] .token-COMMA,
    :root[data-theme="light"] .token-DOT,
    :root[data-theme="light"] .token-DOTDOT,
    :root[data-theme="light"] .token-AMP {
      color: #333333;
    }

    .token-UNKNOWN {
      background-color: rgba(255, 0, 0, 0.2);
      color: red !important;
      text-decoration: wavy underline red;
    }

    .token-EOF {
      color: transparent;
    }

    /* --- Token é«˜äº®æ ·å¼ç»“æŸ --- */


    .panel-header,
    #tab-selector {
      display: flex;
      align-items: center;
      padding: 8px 12px;
      background: var(--header-bg);
      border-bottom: 1px solid var(--border);
      height: 48px;
      box-sizing: border-box;
    }

    .panel-header {
      justify-content: space-between;
      font-weight: 500;
    }

    #tab-selector {
      justify-content: flex-start;
    }
  </style>
</head>

<body>
  <div id="left-panel">
    <div id="editor-container">
      <div class="panel-header">
        <span>Editor</span>
        <button id="theme-toggle" title="Toggle Theme">ğŸŒ™</button>
      </div>
      <textarea id="editor">
// åœ¨è¿™é‡Œè¾“å…¥ Rust-like ä»£ç 
fn example(mut a:i32) {
  while a > 0 {
    a = a - 1;
  }
}

fn main() {
  let mut a = 6;
  example(a);
}</textarea>
    </div>

    <div id="error-container">
      <div class="panel-header">
        <span>Problems</span>
      </div>
      <div id="error-info">0 errors, 0 warnings</div>
    </div>
  </div>

  <div id="right-panel">
    <div id="right-content">
      <div id="tab-selector">
        <select id="display-selector">
          <option value="syntax-tree-container">Syntax Tree</option>
          <option value="quadruples-container">Intermediate Code</option>
          <option value="mips-code-container">MIPS Code</option>
          <option value="parsing-tables-container">Parsing Tables</option>
        </select>
        <div class="tab-controls">
          <button id="zoom-in" title="Zoom In">ï¼‹</button>
          <button id="zoom-out" title="Zoom Out">ï¼</button>
          <button id="save-mips" title="Save MIPS Code">Save .asm</button>
        </div>
      </div>

      <div id="content-display">
        <div id="error-display-overlay" class="error-display-overlay" style="display: none;">
        </div>

        <div id="syntax-tree-container" class="content-pane active">
          <svg id="tree-svg"></svg>
        </div>

        <div id="quadruples-container" class="content-pane">
          <div id="quadruples-table-wrapper"></div>
        </div>

        <div id="mips-code-container" class="content-pane">
          <pre id="mips-code-content"></pre>
        </div>

        <div id="parsing-tables-container" class="content-pane">
          <div class="table-switcher">
            <button class="table-btn active" data-table-type="action">Action Table</button>
            <button class="table-btn" data-table-type="goto">Goto Table</button>
          </div>
          <div class="tables-wrapper">
            <div id="action-table-content" class="parse-table active"></div>
            <div id="goto-table-content" class="parse-table"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const root = document.documentElement;
    const themeToggle = document.getElementById("theme-toggle");
    const editor = CodeMirror.fromTextArea(
      document.getElementById("editor"),
      {
        mode: "rust",
        lineNumbers: true,
        theme: root.getAttribute("data-theme") === "light" ? "vscode-light" : "vscode-dark",
      }
    );

    let lastParseResult = null;
    let parsingTablesData = { action: null, goto: null };
    let errorMarks = [];
    let tokenMarks = [];

    // D3 è¯­æ³•æ ‘ç›¸å…³
    const svg = d3.select("#tree-svg");
    const g = svg.append("g"); // ä¸» <g> å…ƒç´ ç”¨äºå˜æ¢
    const zoom = d3.zoom().scaleExtent([0.1, 4]).on("zoom", (event) => {
      g.attr("transform", event.transform);
    });
    svg.call(zoom).on("dblclick.zoom", null);


    function switchTheme() {
      const currentTheme = root.getAttribute("data-theme");
      const nextTheme = currentTheme === "light" ? "dark" : "light";
      root.setAttribute("data-theme", nextTheme);
      themeToggle.textContent = nextTheme === "light" ? "ğŸŒ™" : "â˜€ï¸";
      editor.setOption("theme", nextTheme === "light" ? "vscode-light" : "vscode-dark");
      if (lastParseResult && lastParseResult.tree && !lastParseResult.error) { // åªåœ¨æ— é”™è¯¯ä¸”æœ‰æ ‘æ—¶é‡ç»˜
        renderTree(lastParseResult.tree);
      }
    }
    themeToggle.addEventListener("click", switchTheme);

    function clearAllMarks() {
      tokenMarks.forEach((m) => m.clear());
      tokenMarks = [];
      errorMarks.forEach((m) => m.clear());
      errorMarks = [];
    }

    function highlightErrors(errorData) {
      errorMarks.forEach((m) => m.clear());
      errorMarks = [];
      if (errorData && errorData.tok && errorData.tok.loc) {
        const tok = errorData.tok;
        const from = { line: tok.loc.row - 1, ch: tok.loc.col - 1 };
        const to = { line: tok.loc.row - 1, ch: tok.loc.col - 1 + (tok.content ? tok.content.length : 1) };
        errorMarks.push(
          editor.getDoc().markText(from, to, { className: "cm-error-underline" })
        );
      }
    }

    function markTokens(tokens) {
      tokens.forEach((tok) => {
        if (tok.loc && typeof tok.loc.row === 'number' && typeof tok.loc.col === 'number' && tok.content) {
          const from = { line: tok.loc.row - 1, ch: tok.loc.col - 1 };
          const to = { line: tok.loc.row - 1, ch: tok.loc.col - 1 + tok.content.length };
          tokenMarks.push(
            editor.getDoc().markText(from, to, {
              className: "token-" + tok.prop,
            })
          );
        }
      });
    }

    function debounce(fn, delay = 500) {
      let t;
      return (...args) => {
        clearTimeout(t);
        t = setTimeout(() => fn(...args), delay);
      };
    }

    // ---------------- PANES AND DISPLAY LOGIC ----------------
    const displaySelector = document.getElementById("display-selector");
    const allContentPanesNodeList = document.querySelectorAll(".content-pane"); // NodeList
    const errorDisplayOverlay = document.getElementById("error-display-overlay");


    function updateActivePaneContent(selectedPaneId, data) {
      if (!data) return;

      allContentPanesNodeList.forEach(pane => {
        if (pane.id === selectedPaneId) {
          pane.classList.add("active");
        } else {
          pane.classList.remove("active");
        }
      });

      if (selectedPaneId === "syntax-tree-container") {
        if (data.tree && Object.keys(data.tree).length > 0) {
          renderTree(data.tree); // renderTree ä¼šå…ˆæ¸…ç©º g
          // è‡ªåŠ¨ç¼©æ”¾é€»è¾‘
          const bounds = g.node().getBBox();
          const parent = svg.node().parentElement; // Should be syntax-tree-container
          const fullWidth = parent.clientWidth;
          const fullHeight = parent.clientHeight;

          const width = bounds.width;
          const height = bounds.height;

          if (width > 0 && height > 0) { // Ensure bounds are valid
            const midX = bounds.x + width / 2;
            const midY = bounds.y + height / 2;
            // Reduce scale slightly more to ensure padding
            const scale = Math.min(0.9, Math.min(fullWidth / width, fullHeight / height) * 0.85);

            svg.call(zoom.transform, d3.zoomIdentity
              .translate(fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY)
              .scale(scale));
          } else { // Empty tree or error in bounding box
            svg.call(zoom.transform, d3.zoomIdentity); // Reset zoom for empty tree
          }
        } else {
          g.selectAll("*").remove(); // Clear if no tree data
          svg.call(zoom.transform, d3.zoomIdentity); // Reset zoom
        }
      } else if (selectedPaneId === "quadruples-container") {
        renderQuadruplesTable(document.getElementById("quadruples-table-wrapper"), data.quadruples);
      } else if (selectedPaneId === "parsing-tables-container") {
        // Tables are rendered in parseCode(). Here, ensure sub-tab state is correct.
        const actionTableBtn = document.querySelector('.table-btn[data-table-type="action"]');
        const gotoTableBtn = document.querySelector('.table-btn[data-table-type="goto"]');
        const actionTableContent = document.getElementById('action-table-content');
        const gotoTableContent = document.getElementById('goto-table-content');

        // If neither sub-tab is active, default to action table
        if (!actionTableBtn.classList.contains('active') && !gotoTableBtn.classList.contains('active')) {
          actionTableBtn.classList.add('active');
          actionTableContent.classList.add('active');
          gotoTableBtn.classList.remove('active');
          gotoTableContent.classList.remove('active');
        }
      }
      else if (selectedPaneId === "mips-code-container") {
        const preEl = document.getElementById("mips-code-content");
        preEl.textContent = data.mips_code || "No MIPS code generated.";
      }
    }

    displaySelector.addEventListener("change", function () {
      if (!lastParseResult || lastParseResult.error) return; // Don't switch if error or no result
      updateActivePaneContent(this.value, lastParseResult);
    });

    document.querySelectorAll('.table-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const tableType = btn.dataset.tableType;
        document.querySelectorAll('.table-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        document.querySelectorAll('.parse-table').forEach(t => t.classList.remove('active'));
        document.getElementById(`${tableType}-table-content`).classList.add('active');
      });
    });

    document.getElementById("zoom-in").onclick = () => svg.transition().duration(200).call(zoom.scaleBy, 1.2);
    document.getElementById("zoom-out").onclick = () => svg.transition().duration(200).call(zoom.scaleBy, 0.8);

    document.getElementById("save-mips").addEventListener("click", function () {
      if (lastParseResult && lastParseResult.mips_code) {
        const blob = new Blob([lastParseResult.mips_code], { type: "text/plain;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "output.asm";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      } else {
        alert("No MIPS code available to save.");
      }
    });

    // ---------------- RENDERING FUNCTIONS ----------------

    function renderTree(treeData) {
      g.selectAll("*").remove(); // Clear previous tree elements
      if (!treeData || Object.keys(treeData).length === 0) {
        console.log("No tree data to render or empty tree.");
        return;
      }

      const rootNode = d3.hierarchy(treeData, d => d.children);
      const treeLayout = d3.tree().nodeSize([80, 180]); // Increased spacing: y, x
      treeLayout(rootNode);

      // Links
      const linkSelection = g.selectAll('.link')
        .data(rootNode.links())
        .join('path')
        .attr('class', 'link')
        .attr('d', d3.linkHorizontal()
          .x(d => d.y)
          .y(d => d.x));

      // Nodes
      const nodeSelection = g.selectAll('.node')
        .data(rootNode.descendants())
        .join('g')
        .attr('class', 'node') // Base class for all nodes
        .attr('transform', d => `translate(${d.y},${d.x})`)
        .on('mouseover', function (event, d_hover) { // 'd_hover' is the data for the hovered node
          nodeSelection.classed('node--hover', n_data => n_data === d_hover);
          linkSelection.classed('link--hover', l_data => l_data.source === d_hover || l_data.target === d_hover);

          const subtreeNodesData = d_hover.descendants();
          nodeSelection.classed('subtree-highlight', n_data => subtreeNodesData.includes(n_data));
          linkSelection.classed('subtree-highlight', l_data =>
            subtreeNodesData.includes(l_data.source) && subtreeNodesData.includes(l_data.target)
          );
        })
        .on('mouseout', function (event, d_hover) {
          nodeSelection.classed('node--hover', false);
          linkSelection.classed('link--hover', false);
          nodeSelection.classed('subtree-highlight', false);
          linkSelection.classed('subtree-highlight', false);
        });

      nodeSelection.append('circle')
        .attr('r', 7); // Radius was already set in CSS, can be controlled here too

      nodeSelection.append('text')
        .attr('dy', '0.31em') // Vertical alignment
        .attr('x', d => d.children ? -12 : 12) // Position text left of parent, right of leaf
        .attr('text-anchor', d => d.children ? 'end' : 'start')
        .text(d => d.data.root);
      // Text halo effect is now handled by CSS 'paint-order' and 'stroke' on .node text
    }


    function renderQuadruplesTable(containerEl, quadruples) {
      containerEl.innerHTML = "";
      if (!Array.isArray(quadruples) || quadruples.length === 0) {
        containerEl.textContent = "No intermediate code generated.";
        return;
      }
      const table = document.createElement("table");
      table.className = "quadruple-table";
      const headerRow = document.createElement("tr");
      ["Index", "Op", "Arg1", "Arg2", "Result"].forEach(text => {
        const th = document.createElement("th");
        th.textContent = text;
        headerRow.appendChild(th);
      });
      table.appendChild(headerRow);
      quadruples.forEach((quad, i) => {
        const row = document.createElement("tr");
        [i, quad.op || "_", quad.arg1 || "_", quad.arg2 || "_", quad.result || "_"].forEach(text => {
          const td = document.createElement("td");
          td.textContent = text;
          row.appendChild(td);
        });
        table.appendChild(row);
      });
      containerEl.appendChild(table);
    }

    function createCell(tag, content) {
      const cell = document.createElement(tag);
      cell.textContent = content;
      return cell;
    }

    function renderParseTable(containerId, tableData, type) {
      const container = document.getElementById(containerId);
      container.innerHTML = '';

      if (!tableData || Object.keys(tableData).length === 0) {
        container.textContent = `No ${type} table data available.`;
        return;
      }

      const symbols = new Set();
      Object.values(tableData).forEach(entries => {
        Object.keys(entries).forEach(symbolId => symbols.add(symbolId));
      });

      const sortedSymbolIds = Array.from(symbols).map(Number).sort((a, b) => a - b);

      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const tbody = document.createElement('tbody');
      const headerRow = document.createElement('tr');
      headerRow.appendChild(createCell('th', 'State'));
      sortedSymbolIds.forEach(symbolId => {
        headerRow.appendChild(createCell('th', symbolId.toString()));
      });
      thead.appendChild(headerRow);

      Object.entries(tableData)
        .sort(([stateA], [stateB]) => Number(stateA) - Number(stateB))
        .forEach(([state, actions]) => {
          const row = document.createElement('tr');
          row.appendChild(createCell('td', state));
          sortedSymbolIds.forEach(symbolIdStr => {
            const symbolKey = symbolIdStr.toString();
            const action = actions[symbolKey] || '';
            const cell = createCell('td', '');

            if (action) {
              if (type === 'action') {
                if (action.startsWith('shift')) cell.className = 'shift';
                else if (action.startsWith('reduce')) cell.className = 'reduce';
                else if (action === 'accept') cell.className = 'accept';
                cell.textContent = action;
              } else if (type === 'goto') {
                cell.textContent = action;
              }
            }
            row.appendChild(cell);
          });
          tbody.appendChild(row);
        });
      table.appendChild(thead);
      table.appendChild(tbody);
      container.appendChild(table);
    }

    // ---------------- PARSING AND INITIALIZATION ----------------
    async function parseCode() {
      const errorInfoEl = document.getElementById("error-info");
      try {
        const res = await fetch("/api/parse", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ code: editor.getValue() }),
        });
        if (!res.ok) {
          const errorText = await res.text(); // Attempt to get more error details
          errorDisplayOverlay.textContent = `Server Error: ${res.status}. ${errorText || 'No additional error message.'}`;
          errorDisplayOverlay.style.display = "flex";
          allContentPanesNodeList.forEach(pane => pane.classList.remove("active"));
          throw new Error(`Server error: ${res.status} ${errorText}`);
        }
        const data = await res.json();
        lastParseResult = data;

        clearAllMarks();
        errorDisplayOverlay.style.display = "none";

        if (data.error) {
          errorInfoEl.textContent = `Error: ${data.error.content} (line ${data.error.loc.row}, col ${data.error.loc.col})`;
          errorInfoEl.style.color = "var(--error-fg)";
          errorDisplayOverlay.textContent = `Error: ${data.error.content}\nAt line ${data.error.loc.row}, column ${data.error.loc.col}`;
          errorDisplayOverlay.style.display = "flex";
          allContentPanesNodeList.forEach(pane => pane.classList.remove("active"));

          if (data.tokens) markTokens(data.tokens);
          highlightErrors(data.error);
        } else {
          errorInfoEl.textContent = "0 errors, 0 warnings";
          errorInfoEl.style.color = "var(--fg-main)";

          parsingTablesData.action = data.action || {};
          parsingTablesData.goto = data.goto || {};

          if (data.tokens) markTokens(data.tokens);

          renderParseTable("action-table-content", parsingTablesData.action, "action");
          renderParseTable("goto-table-content", parsingTablesData.goto, "goto");

          updateActivePaneContent(displaySelector.value, data);
        }
      } catch (err) {
        console.error("Parsing request failed:", err);
        if (!errorDisplayOverlay.style.display || errorDisplayOverlay.style.display === "none") {
          errorDisplayOverlay.textContent = "Error communicating with server or processing response.";
          errorDisplayOverlay.style.display = "flex";
        }
        errorInfoEl.textContent = `Failed to communicate with server: ${err.message}`;
        errorInfoEl.style.color = "var(--error-fg)";
        allContentPanesNodeList.forEach(pane => pane.classList.remove("active"));
      }
    }

    const debouncedParse = debounce(parseCode, 600);
    editor.on("change", debouncedParse);

    // Initial setup
    const preferredTheme = localStorage.getItem("theme") ||
      (window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light");
    if (preferredTheme === "dark") { // Correctly apply dark theme if preferred
      root.setAttribute("data-theme", "dark");
      themeToggle.textContent = "â˜€ï¸";
      editor.setOption("theme", "vscode-dark");
    } else { // Default to light
      root.setAttribute("data-theme", "light");
      themeToggle.textContent = "ğŸŒ™";
      editor.setOption("theme", "vscode-light");
    }

    parseCode(); // Initial parse
  </script>
</body>

</html>